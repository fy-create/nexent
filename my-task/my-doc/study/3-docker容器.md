# Docker 容器和镜像的关系

## 核心概念对比

| 特性 | 镜像 (Image) | 容器 (Container) |
|------|-------------|------------------|
| **本质** | 静态模板 | 运行实例 |
| **状态** | 只读、不可变 | 可读写、动态 |
| **生命周期** | 持久存在 | 可启动/停止/删除 |
| **数量关系** | 一个镜像 | 可创建多个容器 |

## 关系类比

**镜像就像是「建筑图纸」，容器就像是「实际建筑」**：

- 📋 **镜像**：包含所有构建信息的蓝图
- 🏠 **容器**：根据蓝图建造的实际可居住房屋
- 🏘️ **多容器**：同一图纸可以建造多栋相同的房子

## 具体关系说明

### 1. **镜像是容器的基础**
```bash
# 从镜像创建并运行容器
docker run -d --name my-app nginx:latest

# 一个镜像可以创建多个容器
docker run -d --name app1 nginx:latest
docker run -d --name app2 nginx:latest
docker run -d --name app3 nginx:latest
```

### 2. **镜像的分层结构**
```
镜像层级结构：
┌─────────────────┐
│   应用层        │ ← 你的应用代码
├─────────────────┤
│   依赖层        │ ← 库文件、依赖
├─────────────────┤
│   运行时层      │ ← Python/Node.js等
├─────────────────┤
│   操作系统层    │ ← Ubuntu/Alpine等
└─────────────────┘
```

### 3. **容器的可写层**
```
容器 = 镜像 + 可写层
┌─────────────────┐
│   可写层        │ ← 容器运行时的变化
├─────────────────┤
│   镜像层 (只读)  │ ← 来自镜像的所有层
│   镜像层 (只读)  │
│   镜像层 (只读)  │
│   镜像层 (只读)  │
└─────────────────┘
```

## 以你的 Nexent 项目为例

### 镜像构建过程
```dockerfile
# make/web/Dockerfile - 构建前端镜像
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
# ... 配置生产环境
EXPOSE 3000
CMD ["npm", "start"]
```

### 容器运行实例
```yaml
# docker-compose.yml - 从镜像创建容器
nexent-web:
  image: ${NEXENT_WEB_IMAGE}  # 使用镜像
  container_name: nexent-web  # 创建容器
  ports:
    - "3000:3000"
  environment:
    - HTTP_BACKEND=http://nexent:5010
```

## 生命周期管理

### 镜像操作
```bash
# 构建镜像
docker build -t my-app:v1.0 .

# 查看镜像
docker images

# 删除镜像
docker rmi my-app:v1.0
```

### 容器操作
```bash
# 创建并启动容器
docker run -d --name my-container my-app:v1.0

# 查看运行中的容器
docker ps

# 停止容器
docker stop my-container

# 删除容器
docker rm my-container
```

## 实际工作流程

1. **开发阶段**：编写 Dockerfile 定义镜像
2. **构建阶段**：`docker build` 创建镜像
3. **分发阶段**：推送镜像到仓库
4. **部署阶段**：`docker run` 从镜像创建容器
5. **运行阶段**：容器提供服务
6. **更新阶段**：构建新镜像，替换旧容器

## 关键特性

### 镜像特性
- ✅ **不可变性**：一旦构建完成，内容不会改变
- ✅ **可复用性**：同一镜像可创建多个容器
- ✅ **分层存储**：相同层可在多个镜像间共享
- ✅ **版本管理**：通过标签管理不同版本

### 容器特性
- ✅ **隔离性**：每个容器独立运行
- ✅ **可变性**：运行时可以修改文件系统
- ✅ **临时性**：删除容器后，未持久化的数据丢失
- ✅ **轻量级**：共享宿主机内核，启动快速

## 总结

**镜像和容器的关系就像「类」和「对象」的关系**：

- 🎯 **镜像**：定义了应用的完整环境和配置
- 🚀 **容器**：镜像的运行实例，提供实际服务
- 🔄 **一对多**：一个镜像可以创建无数个容器
- 📦 **封装性**：镜像封装环境，容器封装进程

这种设计让应用部署变得标准化、可预测，解决了"在我机器上能跑"的经典问题！
        